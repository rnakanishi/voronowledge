<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.4.3">Jekyll</generator><link href="/voronowledge/feed.xml" rel="self" type="application/atom+xml" /><link href="/voronowledge/" rel="alternate" type="text/html" /><updated>2017-06-13T17:47:50-03:00</updated><id>/voronowledge/</id><title type="html">Voronowledge</title><entry><title type="html">Integração numérica</title><link href="/voronowledge/blog/2017/06/12/numerical-integration.html" rel="alternate" type="text/html" title="Integração numérica" /><published>2017-06-12T00:00:00-03:00</published><updated>2017-06-12T00:00:00-03:00</updated><id>/voronowledge/blog/2017/06/12/numerical-integration</id><content type="html" xml:base="/voronowledge/blog/2017/06/12/numerical-integration.html">&lt;p&gt;O objetivo dos métodos de integração numérica é encontrar a área abaixo da curva da função que se deseja interpolar. Ou seja, dado uma função real &lt;script type=&quot;math/tex&quot;&gt;f \in C[a,b]&lt;/script&gt; queremos calcular $$\int^b_a f(x)dx$$. Observe que:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;f(x)&lt;/script&gt; pode ser uma função complexa de integrar;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;f(x)&lt;/script&gt; pode ser uma função amostrada em tabela.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;regra-do-ponto-médio&quot;&gt;Regra do ponto médio&lt;/h2&gt;
&lt;p&gt;Para se encontrar um método numérico básico, relembremos uma das propriedades de integrais: um intervalo de integração pode ser subdividido em dois subintervalos, ou seja, dado &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
a&lt;c&lt;b %]]&gt;&lt;/script&gt;, podemos fazer: $$\int^b_a f(x)dx = \int^c_a f(x)dx + \int_c^b f(x)dx.$$&lt;/p&gt;

&lt;p&gt;Definimos então a regra do ponto médio: dado &lt;script type=&quot;math/tex&quot;&gt;f(x)\in C[a,b]&lt;/script&gt;, e &lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt; subintervalos em &lt;script type=&quot;math/tex&quot;&gt;[a,b]&lt;/script&gt; de comprimento &lt;script type=&quot;math/tex&quot;&gt;h = \frac{b-a}{N}&lt;/script&gt; com &lt;script type=&quot;math/tex&quot;&gt;x_0 = a&lt;/script&gt; e &lt;script type=&quot;math/tex&quot;&gt;x_N = b&lt;/script&gt;, temos: $$\int_{x_0}^{x_N} f(x)dx \approx h \sum_{k=1}^N f(\bar{x}_k),$$com &lt;script type=&quot;math/tex&quot;&gt;\bar{x}_k = \frac{x_{k-1}+x_k}{2}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/voronowledge/assets/blog-images/integration/midrule.png&quot; alt=&quot;Regra do ponto médio&quot; class=&quot;image medium&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image caption medium&quot;&gt;Figura ilustrativa da regra do ponto médio.&lt;/p&gt;

&lt;h2 id=&quot;quadratura-de-newton-cotes&quot;&gt;Quadratura de Newton-Cotes&lt;/h2&gt;
&lt;p&gt;A estratégia adotada pelos métodos de quadratura é tentar encontrar uma aproximação para a integral &lt;script type=&quot;math/tex&quot;&gt;\int_a^b f(x)dx&lt;/script&gt; usando uma combinação linear de valores de f(x): $$\int_a^b f(x)dx \approx \sum_{k=0}^N A_k f(x_k),$$ em que &lt;script type=&quot;math/tex&quot;&gt;x_k&lt;/script&gt; são chamados de pontos de quadratura e &lt;script type=&quot;math/tex&quot;&gt;A_k&lt;/script&gt; são os coeficientes de quadratura.&lt;/p&gt;

&lt;p&gt;A integração de Newton-Cotes envolve integrar o polinômio de interpolação &lt;script type=&quot;math/tex&quot;&gt;P_n(x)&lt;/script&gt;. Sejam &lt;script type=&quot;math/tex&quot;&gt;(n+1)&lt;/script&gt; pontos igualmente espaçados, e uma função &lt;script type=&quot;math/tex&quot;&gt;f: [a,b]\to \mathbb(R)&lt;/script&gt; (conhecida ou não), cujos valores nos pontos são conhecidos, &lt;script type=&quot;math/tex&quot;&gt;y_i = f(x_i)&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;i = 0, \cdots, n&lt;/script&gt;. Pela fórmula de quadratura, temos: $$\int_a^b f(x)dx = \int_{x_0}^{x_n} f(x)dx \approx \int_{x_0}^{x_n} P_n(x)dx = \sum_{k=0}^{n}y_k \int_{x_0}^{x_n}l_k(x)dx.$$ Observe que, o coeficiente de quadratura corresponde à integral do polinômio de Lagrange, &lt;script type=&quot;math/tex&quot;&gt;A_k = \int_{x_0}^{x_n}l_k(x)dx&lt;/script&gt;.
Realizando uma mudança de variável &lt;script type=&quot;math/tex&quot;&gt;x = x_0 + th&lt;/script&gt;, temos que &lt;script type=&quot;math/tex&quot;&gt;dx = h dt&lt;/script&gt; e quando &lt;script type=&quot;math/tex&quot;&gt;\begin{cases}x = x_0, t = 0\\x = x_n, t = n\end{cases}&lt;/script&gt;. Então, temos $$\int_{x_0}^{x_n}f(x)dx \approx \sum_{k=0}^n y_kh\int_0^n\lambda_k(t)dt = \sum_{k=0}^n y_khC_k^n$$. Observe que $$\lambda_k(t) = \frac{\prod_{i=0,i\neq k}^n(t-i)}{\prod_{i=0,i\neq k}^n(k-i)}.$$&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/voronowledge/assets/blog-images/integration/trapezio.png&quot; alt=&quot;Regra do trapézio&quot; class=&quot;image right&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image right caption&quot;&gt;Figura ilustrativa da Regra do Trapézio&lt;/p&gt;

&lt;h3 id=&quot;regra-do-trapezio&quot;&gt;Caso &lt;script type=&quot;math/tex&quot;&gt;n=1&lt;/script&gt;: Regra do trapézio&lt;/h3&gt;
&lt;p&gt;Como temos apenas dois pontos de quadratura (&lt;script type=&quot;math/tex&quot;&gt;x_0&lt;/script&gt; e &lt;script type=&quot;math/tex&quot;&gt;x_1&lt;/script&gt;), realizamos a integração nesse intervalo.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{eqnarray}
\int_{x_0}^{x_1}f(x)dx &amp;=&amp; \sum_{k=0}^1 y_khC_k^1 \\
&amp;=&amp; y_0hC_0^1 + y_1hC_1^1
\end{eqnarray} %]]&gt;&lt;/script&gt;

&lt;p&gt;Observe que as integrais dos termos &lt;script type=&quot;math/tex&quot;&gt;C_k^1&lt;/script&gt; resultam em &lt;script type=&quot;math/tex&quot;&gt;C_0^1 = C_1^1 = \frac{1}{2}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Então, a regra de quadratura para Newton-Cotes com dois pontos (&lt;em&gt;Regra do trapézio&lt;/em&gt;) é: $$\int_{x_0}^{x_1}f(x)dx = \frac{h}{2}(y_0+y_1)$$&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/voronowledge/assets/blog-images/integration/simpson.png&quot; alt=&quot;Regra 1/3 de Simpson&quot; class=&quot;image right&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image right caption&quot;&gt;Figura ilustrativa da Regra 1/3 de Simpson&lt;/p&gt;

&lt;h3 id=&quot;13-de-simpson&quot;&gt;Caso &lt;script type=&quot;math/tex&quot;&gt;n=2&lt;/script&gt;: Regra 1/3 de Simpson&lt;/h3&gt;
&lt;p&gt;Seguindo o raciocínio análogo à regra do trapézio, temos 3 pontos de quadratura (&lt;script type=&quot;math/tex&quot;&gt;x_0, x_1&lt;/script&gt; e &lt;script type=&quot;math/tex&quot;&gt;x_2&lt;/script&gt;).&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{eqnarray}
\int_{x_0}^{x_2}f(x)dx &amp;=&amp; \sum_{k=0}^2 y_khC_k^1 \\
&amp;=&amp; y_0hC_0^2 + y_1hC_1^2 + y_2hC_2^2
\end{eqnarray} %]]&gt;&lt;/script&gt;

&lt;p&gt;E realizando a integração dos coeficientes de quadratura, obtemos &lt;script type=&quot;math/tex&quot;&gt;C_0^2 = C_2^2 = \frac{1}{3}&lt;/script&gt; e &lt;script type=&quot;math/tex&quot;&gt;C_1^2 = \frac{4}{3}.&lt;/script&gt; Então temos que a regra de quadratura é: $$\int_{x_0}^{x_2}f(x)dx = \frac{h}{3}(y_0+4y_1+y_2)$$&lt;/p&gt;

&lt;h2 id=&quot;quadratura-de-gauss&quot;&gt;Quadratura de Gauss&lt;/h2&gt;

&lt;p&gt;As fórmulas de Newton-Cotes aproximam valores para a integral de &lt;script type=&quot;math/tex&quot;&gt;f(x)&lt;/script&gt; em um intervalo com nós igualmente espaçados. Porém, a generalização das fórmulas pode reduzir a precisão do método. Uma abordagem para encontrar a melhor reta que calcula a área abaixo da curva é utilizando a quadratura de Gauss.&lt;/p&gt;

&lt;p&gt;A quadratura de Gauss escolhe nós de maneira ótima, ou seja, o método tenta minimizar o erro de integração escolhendo pontos &lt;script type=&quot;math/tex&quot;&gt;\xi_0,\cdots,\xi_n\in[a,b]&lt;/script&gt; e coeficientes &lt;script type=&quot;math/tex&quot;&gt;\omega_0,\cdots,\omega_n&lt;/script&gt; tais que $$\int_a^b f(x)dx \approx \sum_{k=0}^n \omega_kf(\xi_k).$$
Para garantir a precisão, assume-se que a melhor escolha fornece um resultado exato quando &lt;script type=&quot;math/tex&quot;&gt;f\in P_m&lt;/script&gt;, em que &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; é o grau de precisão. Nesse caso, escolhemos &lt;script type=&quot;math/tex&quot;&gt;m = 2n+1&lt;/script&gt;, uma vez que temos &lt;script type=&quot;math/tex&quot;&gt;2m+2&lt;/script&gt; variáveis a serem otimizadas.&lt;/p&gt;

&lt;p&gt;Supondo que tenhamos uma função $f$ polinomial, queremos que ela seja exata com &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; pontos. Então, por substituição dos valores, e resolvendo a integral, chega-se em um sistema que é possível determinar os valores dos pesos &lt;script type=&quot;math/tex&quot;&gt;\omega_k&lt;/script&gt; e &lt;script type=&quot;math/tex&quot;&gt;\xi_k&lt;/script&gt;. Porém, muito comumente é encontrado os valores para essas variáveis já tabelados pelos polinômios de Legendre.&lt;/p&gt;

&lt;h3 id=&quot;polinômios-de-legendre&quot;&gt;Polinômios de Legendre&lt;/h3&gt;

&lt;blockquote class=&quot;definition&quot;&gt;
  &lt;p&gt;&lt;strong&gt;Polinômios ortogonais&lt;/strong&gt; são polinômios da família &lt;script type=&quot;math/tex&quot;&gt;{\phi_0, \phi_1, \cdots, \phi_n, \cdots}&lt;/script&gt; definidos em &lt;script type=&quot;math/tex&quot;&gt;[a,b]&lt;/script&gt; com &lt;script type=&quot;math/tex&quot;&gt;grau(\phi_n)=n&lt;/script&gt; (e &lt;script type=&quot;math/tex&quot;&gt;\phi_0\neq 0&lt;/script&gt;), tais que
$$\langle\phi_m,\phi_n\rangle = \int_a^b W(x)[\phi_m(x)\phi_n(x)]dx = 0\quad \text{se } m\neq n.$$.
&lt;script type=&quot;math/tex&quot;&gt;W(x)&lt;/script&gt; é positivo e é dita função peso, com &lt;script type=&quot;math/tex&quot;&gt;W\in C[a,b]&lt;/script&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Considerando um intervalo &lt;script type=&quot;math/tex&quot;&gt;[-1,1]&lt;/script&gt; e o produto interno com função peso &lt;script type=&quot;math/tex&quot;&gt;W(x) = 1&lt;/script&gt;, os &lt;em&gt;polinômios de Legendre&lt;/em&gt; são gerados pela recursão:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{eqnarray}
    \phi_0(x) &amp;=&amp; 1\\
    \phi_1(x) &amp;=&amp; x\\
    \phi_{k+1}(x) &amp;=&amp; \frac{2k+1}{k+1}x\phi_k(x) - \frac{k}{k+1}\phi_{k-1}(x)\quad k = 1,2,\cdots
\end{eqnarray} %]]&gt;&lt;/script&gt;

&lt;h3 id=&quot;quadratura-de-gauss-legendre&quot;&gt;Quadratura de Gauss-Legendre&lt;/h3&gt;
&lt;p&gt;A quadratura de Gauss-Legendre envolve determinar as raízes &lt;script type=&quot;math/tex&quot;&gt;\xi_k&lt;/script&gt; de &lt;script type=&quot;math/tex&quot;&gt;\phi_{n+1}(x)&lt;/script&gt; utilizando os polinômios de Legendre e então determinar os pesos para cada raiz. Na prática, os valores de &lt;script type=&quot;math/tex&quot;&gt;\xi_k&lt;/script&gt; e &lt;script type=&quot;math/tex&quot;&gt;\omega_k&lt;/script&gt; são tabelados para cada valor de &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;:&lt;/p&gt;

&lt;table class=&quot;bottom-line&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;n&lt;/th&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;\xi_k&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;\omega_k&lt;/script&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\pm&lt;/script&gt;0.5773502691&lt;/td&gt;
      &lt;td&gt;1.0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\pm&lt;/script&gt;0.7745966692&lt;/td&gt;
      &lt;td&gt;0.555555555&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0.0&lt;/td&gt;
      &lt;td&gt;0.888888888&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\pm&lt;/script&gt;0.8611363115&lt;/td&gt;
      &lt;td&gt;0.3478548451&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\pm&lt;/script&gt;0.3399810435&lt;/td&gt;
      &lt;td&gt;0.6521451548&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\pm&lt;/script&gt;0.9061798459&lt;/td&gt;
      &lt;td&gt;0.2369268850&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\pm&lt;/script&gt;0.5384693101&lt;/td&gt;
      &lt;td&gt;0.4786286704&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0.0&lt;/td&gt;
      &lt;td&gt;0.5688888888&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Observe que as quadraturas de Gauss-Legendre são apenas para integrais no intervalo &lt;script type=&quot;math/tex&quot;&gt;[-1,1]&lt;/script&gt;. Para integrar em um intervalo genérico &lt;script type=&quot;math/tex&quot;&gt;[a,b]&lt;/script&gt; é necessário realizar a mudança de intervalos de integração: $$\int_{-a}^{b}f(x)dx = \frac{b-a}{2}\int_{-1}^1f(\frac{(b-a)t+b+a}{2}) dt.$$&lt;/p&gt;</content><author><name>RNakanishi</name></author><category term="numerical-methods" /><category term="pt-br" /><summary type="html">O objetivo dos métodos de integração numérica é encontrar a área abaixo da curva da função que se deseja interpolar. Ou seja, dado uma função real queremos calcular $$\int^b_a f(x)dx$$. Observe que:</summary></entry><entry><title type="html">Métodos de interpolação</title><link href="/voronowledge/blog/2017/05/25/interpolation.html" rel="alternate" type="text/html" title="Métodos de interpolação" /><published>2017-05-25T00:00:00-03:00</published><updated>2017-05-25T00:00:00-03:00</updated><id>/voronowledge/blog/2017/05/25/interpolation</id><content type="html" xml:base="/voronowledge/blog/2017/05/25/interpolation.html">&lt;p&gt;Interpolações são métodos utilizados quando se deseja saber o valor desconhecido dentro de um intervalo dado por uma amostra. Como, muitas vezes, não é possível saber qual a função que gera os pontos, utiliza-se de métodos numéricos para se estimá-la. Dessa forma, podemos estimar o comportamento dos demais pontos dentro do intervalo.&lt;/p&gt;

&lt;figure class=&quot;graph-full&quot;&gt; &lt;/figure&gt;

&lt;p class=&quot;graph caption&quot;&gt;A partir dos pontos amostrados, queremos saber o comportamento de uma possível função que passa por tais pontos.&lt;/p&gt;

&lt;p&gt;É possível encontrar vários métodos de interpolação. Em nosso escopo, trataremos dos métodos pioneiros que interpolam a função utilizando todos os pontos dados (&lt;em&gt;interpolação de Lagrange&lt;/em&gt;) e métodos que também conseguem utilizar informação de derivada, quando presente (&lt;em&gt;interpolação de Hermite&lt;/em&gt;) Entretanto, como veremos mais a frente, seu principal problema é que o grau do polinômio gerado cresce com o número de amostras. E isso motiva o uso de métodos que interpolam com menos pontos, mas que conseguem apresentar bons resultados (&lt;em&gt;Splines lineares&lt;/em&gt; e &lt;em&gt;cúbicas&lt;/em&gt;).&lt;/p&gt;

&lt;h2 id=&quot;polinômios-de-lagrange&quot;&gt;Polinômios de Lagrange&lt;/h2&gt;

&lt;blockquote class=&quot;theorem pt-br&quot;&gt;
  &lt;p&gt;Sejam &lt;script type=&quot;math/tex&quot;&gt;x_0, x_1, ..., x_n&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;n+1&lt;/script&gt; pontos distintos e &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; o valor da função nesses pontos. Então existe apenas um polinômio &lt;script type=&quot;math/tex&quot;&gt;P(x)&lt;/script&gt; de grau &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; tal que $$P(x_k) = f(x_k)\quad\text{para } k = 0,1,…,n.$$
Esse polinômio é dado por $$ P(x) = \sum_{k=0}^n f(x_k)L_k(x) $$
em que, para cada &lt;script type=&quot;math/tex&quot;&gt;k = 0, 1, ..., n&lt;/script&gt;, $$ L_k(x) = \frac{\prod_{i=0, i\neq k}^n (x-x_i)}{\prod_{i=0, i\neq k}^n(x_k-x_i)}. $$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Como pode-se observar, a construção de um polinômio é capaz de aproximar bem a curva desejada. Entretanto, caso a função original não seja polinomial, mas sim de outra natureza (trigonométrica, exponencial, etc), a interpolação gera um erro. É de interesse saber qual a grandeza desse erro para que as estimativas sejam o mais precisas possíveis. Para isso, estima-se um limitante superior para o erro:&lt;/p&gt;

&lt;blockquote class=&quot;theorem pt-br&quot;&gt;
  &lt;p&gt;Suponha &lt;script type=&quot;math/tex&quot;&gt;x_0, x_1, ..., x_n&lt;/script&gt; valores distintos dentro do intervalo &lt;script type=&quot;math/tex&quot;&gt;[a,b]&lt;/script&gt; e &lt;script type=&quot;math/tex&quot;&gt;f \in C^{n+1}[a,b]&lt;/script&gt;. Então, para cada &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; no intervalo, existe um valor &lt;script type=&quot;math/tex&quot;&gt;\xi&lt;/script&gt; desconhecido entre os valores &lt;script type=&quot;math/tex&quot;&gt;x_0, x_1, ..., x_n&lt;/script&gt; e dentro de &lt;script type=&quot;math/tex&quot;&gt;(a,b)&lt;/script&gt; tal que $$ f(x) = P(x) + \frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)(x-x_1)\cdots(x-x_n),$$ com &lt;script type=&quot;math/tex&quot;&gt;P(x)&lt;/script&gt; sendo o polinômio interpolador de Lagrange. O termo somado ao polinômio interpolador é o erro de interpolação do método.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;implementação&quot;&gt;Implementação&lt;/h3&gt;
&lt;p&gt;O código implementado em &lt;code class=&quot;highlighter-rouge&quot;&gt;MatLab&lt;/code&gt; é bem simples e envolve apenas o cálculo do polinômio &lt;script type=&quot;math/tex&quot;&gt;L_k(x)&lt;/script&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-matlab&quot; data-lang=&quot;matlab&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;ones&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;% Polinomio de Lagrange&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xi&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;% Dividendo do produtorio&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;den&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xi&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;% Denominador do produtorio&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;den&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;prod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;prod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;den&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;% Valor avaliado na interpolacao&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;No código acima, temos que &lt;code class=&quot;highlighter-rouge&quot;&gt;xi&lt;/code&gt; são os pontos de interpolação; &lt;code class=&quot;highlighter-rouge&quot;&gt;yi&lt;/code&gt; são os valores da função que se deseja interpolar, avaliado nos pontos &lt;code class=&quot;highlighter-rouge&quot;&gt;xi&lt;/code&gt;; e &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; são os pontos que se deseja calcular, obtendo assim, os valores em &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;.&lt;/p&gt;

&lt;!-- ### Exemplo gráfico
&lt;figure class=&quot;lagrange&quot;&gt; &lt;/figure&gt; --&gt;

&lt;h2 id=&quot;interpolação-de-hermite&quot;&gt;Interpolação de Hermite&lt;/h2&gt;
&lt;p&gt;Para construção do polinômio de hermite, é necessário antes apresentar duas ferramentas: diferenças divididas e polinômios de Newton.&lt;/p&gt;

&lt;h3 id=&quot;diferenças-divididas&quot;&gt;Diferenças divididas&lt;/h3&gt;

&lt;blockquote class=&quot;definition pt-br&quot;&gt;
  &lt;p&gt;Diferenças divididas são definidas recursivamente. Diferenças divididas de ordem-&lt;script type=&quot;math/tex&quot;&gt;0&lt;/script&gt;: $$f[x_i] = f(x_i),\quad i=0,1,\cdots,n$$.
Diferença dividida de ordem-&lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt;: $$f[x_i, x_{i+1}] = \frac{f[x_{i+1}]-f[x_i]}{x_{i+1}-x_{i}} = \frac{f(x_{i+1})-f(x_i)}{x_{i+1}-x_{i}}$$.
Então, uma diferença dividida de ordem-&lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;, entre &lt;script type=&quot;math/tex&quot;&gt;x_i, x_{i+1}, \cdots, x_{i+k}&lt;/script&gt;, é definido como: $$f[x_i, x_{i+1}, \cdots, x_{i+k}] = \frac{f[x_{i+1}, x_{i+2}, \cdots, x_{i+k}] - f[x_i, x_{i+1}, \cdots, x_{i+k-1}]}{x_{i+k}-x_i},$$ com &lt;script type=&quot;math/tex&quot;&gt;k = 1,\cdots,n&lt;/script&gt; e &lt;script type=&quot;math/tex&quot;&gt;i = 0, 1,\cdots,n-k&lt;/script&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Uma forma mais simples de visualizar as diferenças divididas é montando uma tabela das diferenças:&lt;/p&gt;

&lt;table class=&quot;margin-first&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;ordem-&lt;script type=&quot;math/tex&quot;&gt;0&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;ordem-&lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;ordem-&lt;script type=&quot;math/tex&quot;&gt;2&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;ordem-&lt;script type=&quot;math/tex&quot;&gt;3&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;\cdots&lt;/script&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;x_0&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_0]&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_0,x_1]&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_0,x_1,x_2]&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_0,x_1,x_2,x_3]&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;x_1&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_1]&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_2,x_1]&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_1,x_2,x_3]&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\vdots&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;x_2&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_2]&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_3,x_2]&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\vdots&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\vdots&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;x_3&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_3]&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\vdots&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\vdots&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\vdots&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\vdots&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\vdots&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\vdots&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\vdots&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\vdots&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;polinômios-de-newton&quot;&gt;Polinômios de Newton&lt;/h3&gt;
&lt;p&gt;O polinômio interpolador na forma de Newton é dada na seguinte forma: $$P_n(x) = \alpha_0 + \alpha_1(x-x_0) + \cdots + \alpha_n(x-x_0)(x-x_1)\cdots(x-x_{n-1}).$$
E cada coeficiente &lt;script type=&quot;math/tex&quot;&gt;\alpha_k&lt;/script&gt; é determinado utilizando diferenças divididas de ordem &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;:&lt;/p&gt;

&lt;table class=&quot;margin-first&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;ordem-&lt;script type=&quot;math/tex&quot;&gt;0&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;ordem-&lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;ordem-&lt;script type=&quot;math/tex&quot;&gt;2&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;\cdots&lt;/script&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;x_0&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_0] = \alpha_0&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_0,x_1] = \alpha_1&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_0,x_1,x_2] = \alpha_2&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\cdots&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;interpolação-com-derivadas&quot;&gt;Interpolação com derivadas&lt;/h3&gt;

&lt;blockquote class=&quot;theorem pt-br&quot;&gt;
  &lt;p&gt;Seja uma função &lt;script type=&quot;math/tex&quot;&gt;f \in C^n[a,b]&lt;/script&gt; com derivadas contínuas. Dada as condições em cada nó &lt;script type=&quot;math/tex&quot;&gt;x_i&lt;/script&gt; como: $$P_m^{(j)} = f^{(j)} = c_{ij}, \quad 0\leq j\leq k_i-1\quad\text{e } 0\leq i\leq n$$ com &lt;script type=&quot;math/tex&quot;&gt;m+1 = \kappa_0+\kappa_1+\cdots+\kappa_n&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;\kappa_i&lt;/script&gt; sendo o número de condições em um nó &lt;script type=&quot;math/tex&quot;&gt;x_i&lt;/script&gt;, ou seja, informações de derivada fornecidos.
Então, existe um único polinômio &lt;script type=&quot;math/tex&quot;&gt;P_m(x)&lt;/script&gt; que satisfaz as condições de interpolação de Hermite.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Uma maneira de se obter os coeficientes do polinômio interpolador de Hermite é utilizando a tabela de diferenças divididas e o polinômio na forma de Newton.
Para montarmos a tabela de diferenças divididas, repetimos os pontos em que a derivada está presente. Nesse caso, temos que $$f[x_k,x_k] = \lim_{h\to 0}\frac{f(x_k+h)-f(x_k)}{(x_k+h)-x_k} = f’(x_k).$$ E no caso geral, $$f[x_{k_1},\cdots,x_{k_m}] = \frac{1}{(m-1)!}f^{(m-1)}(x_k).$$&lt;/p&gt;

&lt;p&gt;Então, Dados &lt;script type=&quot;math/tex&quot;&gt;n+1&lt;/script&gt; pares de pontos e suas derivadas, queremos obter &lt;script type=&quot;math/tex&quot;&gt;P_{2n+1}(x)&lt;/script&gt; que satisfaz todas as condições dadas: $$P_{2n+1}(x_i) = c_{i0},\quad P_{2n+1}’(x_i)=x_{i1},\quad i=0,\cdots,n.$$&lt;/p&gt;

&lt;table class=&quot;margin-first&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;ordem-&lt;script type=&quot;math/tex&quot;&gt;0&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;ordem-&lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;ordem-&lt;script type=&quot;math/tex&quot;&gt;2&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;ordem-&lt;script type=&quot;math/tex&quot;&gt;3&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;\cdots&lt;/script&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;x_0&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_0]=c_{00}&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_0,x_0]=c_{01}&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_0,x_0,x_1]&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_0,x_0,x_1,x_1]&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\cdots&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;x_0&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_0]&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_0,x_1]&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_0,x_1,x_1]&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_0,x_1,x_1,x_2]&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\cdots&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;x_1&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_1]=c_{10}&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_1,x_1]=c_{11}&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_1,x_1,x_2]&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_1,x_1,x_2,x_2]&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\cdots&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;x_1&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_1]&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_1,x_2]&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_1,x_2,x_2]&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\vdots&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;x_2&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_2]=c_{20}&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_2,x_2]=c_{21}&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\vdots&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\vdots&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;x_2&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;f[x_2]&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\vdots&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\vdots&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\vdots&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\vdots&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\vdots&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\vdots&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\vdots&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\vdots&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;E finalmente, montamos o polinômio de Hermite: $$P_{2n+1}(x) = \alpha_0 + \alpha_1(x-x_0) + \alpha_2(x-x_0)^2 + \alpha_3(x-x_0)^2(x-x_1) + \cdots$$. Observe que os termos quadráticos aparecem por causa do maior número de informações presentes em cada ponto.&lt;/p&gt;

&lt;h3 id=&quot;implementação-1&quot;&gt;Implementação&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-matlab&quot; data-lang=&quot;matlab&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;zeros&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;zeros&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;ones&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;% Matriz de Hermite&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dyi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;...&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;% Completando a matriz&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;...&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;% forma de Newton&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,:)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,:)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;diag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;No código em &lt;code class=&quot;highlighter-rouge&quot;&gt;MatLab&lt;/code&gt; acima, é necessário algumas atenções:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;O vetor &lt;code class=&quot;highlighter-rouge&quot;&gt;z&lt;/code&gt; corresponde à primeira coluna da matriz de diferenças divididas, ou seja, &lt;script type=&quot;math/tex&quot;&gt;x_0, x_0, x_1, x_1, \cdots, x_n, x_n&lt;/script&gt; e ele será usado para construção do polinômio de Newton;&lt;/li&gt;
  &lt;li&gt;Ao construirmos a tabela de diferenças divididas, &lt;code class=&quot;highlighter-rouge&quot;&gt;Q&lt;/code&gt;, temos que tomar cuidado com a indiciação utilizada;&lt;/li&gt;
  &lt;li&gt;Na nossa implementação, a matriz “desce”, ao invés de “se manter no topo”, como mostrado na teoria. Por isso que o polinômio de Newton é multiplicado pela diagonal de &lt;code class=&quot;highlighter-rouge&quot;&gt;Q&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;interpolação-por-partes&quot;&gt;Interpolação por partes&lt;/h2&gt;
&lt;p&gt;Os métodos apresentados anteriormente conseguem encontrar uma interpolação para os pontos dados utilizando apenas um polinômio. Entretanto, caso haja muitos pontos a serem interpolados, o grau do polinômio aumenta e isso pode criar efeitos oscilatórios indesejados (fenômeno de Runge).&lt;/p&gt;

&lt;figure class=&quot;bad-poly&quot;&gt; &lt;/figure&gt;

&lt;p&gt;Uma alternativa para tentar contornar esse problema é criar polinômios interpoladores utilizando subintervalos. Para isso é necessário tomar o cuidado de manter o polinômio contínuo e suave dentro dos subintervalos.&lt;/p&gt;

&lt;h3 id=&quot;splines-lineares&quot;&gt;Splines lineares&lt;/h3&gt;

&lt;h3 id=&quot;splines-cúbicas&quot;&gt;Splines cúbicas&lt;/h3&gt;

&lt;!-- Necessário para usar o D3 --&gt;
&lt;script src=&quot;https://d3js.org/d3.v4.min.js&quot;&gt;&lt;/script&gt;

&lt;!-- Exemplo teaser de interpoação --&gt;
&lt;script&gt;
// Inicializando SVG
var margin = {top: 20, right: 15, bottom: 30, left: 35},
    width = 500 - margin.left - margin.right,
    height = 300 - margin.top - margin.bottom;
var svg = d3.select(&quot;.graph-full&quot;).append(&quot;svg&quot;)
    .attr(&quot;width&quot;, width+margin.left+margin.right)
    .attr(&quot;height&quot;, height+margin.top+margin.bottom)
    .append(&quot;g&quot;).attr(&quot;transform&quot;, &quot;translate(&quot; + margin.left + &quot;,&quot; + margin.top + &quot;)&quot;);

// Definindo eixos
var x = d3.scaleLinear().domain([0, 4]).range([0, width]);
var y = d3.scaleLinear().domain([-0.5, 1.2]).range([height, 0]);
var line = d3.line()
            .x(function(d) { return x(d.x); })
            .y(function(d) { return y(d.y); });

svg.append(&quot;g&quot;)
    .attr(&quot;class&quot;,&quot;axis&quot;)
    .attr(&quot;transform&quot;, &quot;translate(0,&quot; + height + &quot;)&quot;)
    .call(d3.axisBottom().scale(x));

svg.append(&quot;g&quot;)
    .attr(&quot;class&quot;,&quot;axis&quot;)
    .call(d3.axisLeft(y));

// Scatter de pontos
var data = [
        {&quot;x&quot;: 0.25, &quot;y&quot;: 0.25},
        {&quot;x&quot;: 1.00, &quot;y&quot;: 0.47},
        {&quot;x&quot;: 1.25, &quot;y&quot;: 0.95},
        {&quot;x&quot;: 1.75, &quot;y&quot;: 0.99},
        {&quot;x&quot;: 3.10, &quot;y&quot;: 0.15},
        {&quot;x&quot;: 3.47, &quot;y&quot;: 0.27}
    ];
svg.selectAll(&quot;dot&quot;)
    .data(data)
  .enter().append(&quot;circle&quot;)
    .attr(&quot;class&quot;,&quot;curve&quot;)
    .attr(&quot;r&quot;, 3)
    .attr(&quot;cx&quot;, function(d,i) { return x(d.x); })
    .attr(&quot;cy&quot;, function(d) { return y(d.y); })

// Plot de linhas
d3.csv(&quot;/voronowledge/assets/data/interpolation.csv&quot;,
    function(interp){
        interp.forEach( function(d) {
                d.x = +d.x;
                d.y = +d.y;
            });

        svg.append(&quot;path&quot;)
            .attr(&quot;class&quot;,&quot;curve dashed&quot;)
            .attr(&quot;d&quot;, line(interp));
    }
);
&lt;/script&gt;

&lt;!-- Exemplo de polinômio de alto grau e as oscilações --&gt;
&lt;script&gt;
&lt;/script&gt;</content><author><name>RNakanishi</name></author><category term="interpolation" /><category term="numerical-methods" /><category term="pt-br" /><summary type="html">Interpolações são métodos utilizados quando se deseja saber o valor desconhecido dentro de um intervalo dado por uma amostra. Como, muitas vezes, não é possível saber qual a função que gera os pontos, utiliza-se de métodos numéricos para se estimá-la. Dessa forma, podemos estimar o comportamento dos demais pontos dentro do intervalo.</summary></entry><entry><title type="html">A Sparse Paged Grid structure</title><link href="/voronowledge/blog/2017/05/18/spgrid.html" rel="alternate" type="text/html" title="A Sparse Paged Grid structure" /><published>2017-05-18T00:00:00-03:00</published><updated>2017-05-18T00:00:00-03:00</updated><id>/voronowledge/blog/2017/05/18/spgrid</id><content type="html" xml:base="/voronowledge/blog/2017/05/18/spgrid.html">&lt;p&gt;&lt;strong&gt;Disclaimer: This paper was originally written by &lt;em&gt;&lt;a href=&quot;http://stanford.edu/~setaluri/&quot; target=&quot;_blank&quot;&gt;Rajsekhar Setaluri&lt;/a&gt;&lt;/em&gt;, &lt;em&gt;&lt;a href=&quot;http://pages.cs.wisc.edu/~aanjneya/&quot; target=&quot;_blank&quot;&gt;Mridul Aanjaneya&lt;/a&gt;&lt;/em&gt;, &lt;em&gt;Sean Bauer&lt;/em&gt; and &lt;em&gt;&lt;a href=&quot;http://pages.cs.wisc.edu/~sifakis/&quot; target=&quot;_blank&quot;&gt;Eftychios Sifakis&lt;/a&gt;&lt;/em&gt;. Originally published on &lt;em&gt;ACM Transactions on Graphics&lt;/em&gt;, 2014.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/voronowledge/assets/blog-images/spgrid/quadtree-as-sp.png&quot; alt=&quot;Quadtree as pyramid sparse grid&quot; class=&quot;image right&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image right caption&quot;&gt;&lt;strong&gt;Figure 1:&lt;/strong&gt; Quadtree grid converted to a pyramid sparse grid. Source: original paper.&lt;/p&gt;

&lt;p&gt;A new data structure for storing and processing fluids simulations on sparse populated high-resolution uniform grids is presented: &lt;em&gt;SPGrid&lt;/em&gt; (Sparse Paged Grid).
This structure ia able to construct an adaptive discretization for the simulation based on a tree-based representation has been placed (See figure on the right).&lt;/p&gt;

&lt;h2 id=&quot;adaptive-discretization&quot;&gt;Adaptive discretization&lt;/h2&gt;

&lt;p&gt;Adaptive structures are good for simulations because you don’t want to have a fine resolution over all your domain. Instead, you usually want to refine in some regions where more detail is required. However, applying stencils is not an easy thing: accessing neighbors require go through different levels and different nodes of your tree structure.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/voronowledge/assets/blog-images/spgrid/image4146.png&quot; alt=&quot;Quadtree&quot; class=&quot;image medium&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image medium caption&quot;&gt;&lt;strong&gt;Figure 2:&lt;/strong&gt; Accessing neighbors in a quadtree structure requires to go through different levels of the tree. The targeted cell in blue has to travel through all levels to find its neighbors in red.&lt;/p&gt;

&lt;p&gt;The idea behind SPGrid is to substitute the tree-based structure with a pyramid of sparsely populated uniform grids, as shown in the &lt;em&gt;Figure 2&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;pyramid-of-sparsely-populated-uniform-grids&quot;&gt;Pyramid of sparsely populated uniform grids&lt;/h3&gt;
&lt;p&gt;The equation to be solved here is the incompressible inviscid Navier-Stokes equations:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{eqnarray}
    \mathbf{u}_t + (\mathbf{u}\cdot\nabla)\mathbf{u} + \frac{\nabla p}{\rho} &amp;=&amp; \mathbf{f} \\
    \nabla\cdot\mathbf{u} &amp;=&amp; 0

\end{eqnarray} %]]&gt;&lt;/script&gt;

&lt;p&gt;with a splitting scheme. In the equation, &lt;script type=&quot;math/tex&quot;&gt;\mathbf{u} = (u,v,w)&lt;/script&gt; is vector velocity field; &lt;script type=&quot;math/tex&quot;&gt;\mathbf{f}&lt;/script&gt; is the external forces component; &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; is the scalar pressure field; and &lt;script type=&quot;math/tex&quot;&gt;\rho&lt;/script&gt; is the fluid density.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/voronowledge/assets/blog-images/spgrid/active-cells.png&quot; alt=&quot;Active cells and faces&quot; class=&quot;image left&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image left caption&quot;&gt;&lt;strong&gt;Figure 3:&lt;/strong&gt; Active cells and active faces in the pyramid structure. Adapted from the original paper.&lt;/p&gt;

&lt;p&gt;To build the pyramid structure, it’s necessary to identify cells and faces that can carry degrees of freedom. These cells are defined as &lt;em&gt;active cells&lt;/em&gt; and &lt;em&gt;active faces&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A cell is &lt;em&gt;active&lt;/em&gt; if it is present in the geometry and is undivided in the octree;&lt;/li&gt;
  &lt;li&gt;A face is &lt;em&gt;active&lt;/em&gt; if the face is present in the geometry and undivided in the octree;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now that the pyramid structure for the simulations is well declared, it is necessary to perform discrete operations for the simulation: stencil operations within single levels; and operations through different levels of the pyramid.&lt;/p&gt;

&lt;h3 id=&quot;discrete-operators&quot;&gt;Discrete operators&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/voronowledge/assets/blog-images/spgrid/ghost.png&quot; alt=&quot;Ghost points&quot; class=&quot;image left&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image left caption&quot;&gt;&lt;strong&gt;Figure 4:&lt;/strong&gt; Ghost cells are introduced per level of the pyramid structure. Adapted from the original paper.&lt;/p&gt;

&lt;p&gt;Let’s denote with &lt;script type=&quot;math/tex&quot;&gt;l&lt;/script&gt; the level of the pyramid. A cell that lives natively at level &lt;script type=&quot;math/tex&quot;&gt;l&lt;/script&gt;  and has multidimensional index &lt;script type=&quot;math/tex&quot;&gt;I&lt;/script&gt; is denoted as &lt;script type=&quot;math/tex&quot;&gt;C_I^l&lt;/script&gt;.
Also let’s introduce a &lt;em&gt;ghost cell&lt;/em&gt;. &lt;script type=&quot;math/tex&quot;&gt;C_I^l&lt;/script&gt; is a ghost if:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;C_I^l&lt;/script&gt; is not active at level &lt;script type=&quot;math/tex&quot;&gt;l&lt;/script&gt;;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;C_I^l&lt;/script&gt; is neighbor of an active cell at level &lt;script type=&quot;math/tex&quot;&gt;l_{lower} \leq l&lt;/script&gt;,&lt;/li&gt;
  &lt;li&gt;There exists a less refined parent of &lt;script type=&quot;math/tex&quot;&gt;C_I^l&lt;/script&gt; at higher level &lt;script type=&quot;math/tex&quot;&gt;l_{higher}&gt; l&lt;/script&gt; that is active.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Since the ghost cells live in different levels, it is necessary to define operations over those cells:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;Ghost value propagate&lt;/em&gt;: upsampling routine. Each data of level &lt;script type=&quot;math/tex&quot;&gt;l&lt;/script&gt; is copied to a fine ghost children at level &lt;script type=&quot;math/tex&quot;&gt;l-1&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Ghost value accumulate&lt;/em&gt;: downsampling routine. Each data of level &lt;script type=&quot;math/tex&quot;&gt;l&lt;/script&gt; accumulates contributions from any ghost children at level &lt;script type=&quot;math/tex&quot;&gt;l-1&lt;/script&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/voronowledge/assets/blog-images/spgrid/accumulate.png&quot; alt=&quot;Accumulation and propagation operations&quot; class=&quot;image medium&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image caption medium&quot;&gt;&lt;strong&gt;Figure 5:&lt;/strong&gt; Accumulate routine on the left. Propagate routine on the left. Adapted from the original paper.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Discrete gradient&lt;/strong&gt; The pressure gradient values are defined in every face that borders an active cell as &lt;script type=&quot;math/tex&quot;&gt;g = \frac{p_i-p_k}{\Delta}&lt;/script&gt;, for &lt;script type=&quot;math/tex&quot;&gt;i\neq k&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;i,k&lt;/script&gt; cells with a shared face. The case where gradient lives between two cells of the same size is straight forward: &lt;script type=&quot;math/tex&quot;&gt;\Delta = h&lt;/script&gt; is the distance between cells center. In the case where we have neighbors of different sizes, the &lt;em&gt;propagate&lt;/em&gt; routine computed earlier guarantee that there will have a ghost point to compute the gradient. The issue here is which &lt;script type=&quot;math/tex&quot;&gt;\Delta&lt;/script&gt; to use: in this case, &lt;script type=&quot;math/tex&quot;&gt;\Delta = (h+\frac{h}{2})2 = 3/4 h&lt;/script&gt; for a single level transition. As a general rule, &lt;script type=&quot;math/tex&quot;&gt;\Delta = 3h_{min}/2&lt;/script&gt;, where &lt;script type=&quot;math/tex&quot;&gt;h_{min}&lt;/script&gt; is the size of smallest cell.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/voronowledge/assets/blog-images/spgrid/delta-cells.png&quot; alt=&quot;Delta values&quot; class=&quot;image medium&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image medium caption&quot;&gt;&lt;strong&gt;Figure 6:&lt;/strong&gt; Computation of the &lt;script type=&quot;math/tex&quot;&gt;h&lt;/script&gt; value is different for each case.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Divergence&lt;/strong&gt;
The volume-weighted velocity divergence on cell centers is computed as follows:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;V_{cell}\nabla\cdot \mathbf{u} = \sum_{faces}(\mathbf{u}_{face}\cdot\mathbf{n})A_{face}&lt;/script&gt;

&lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;\mathbf{n}&lt;/script&gt; is the outward normal vector and &lt;script type=&quot;math/tex&quot;&gt;A_{face}&lt;/script&gt; is the area of that face. Similarly to gradient, ghost cells are used to compute the contributions of all faces. After all levels divergence was computed, tthe &lt;em&gt;accumulate&lt;/em&gt; routine is called.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Laplacian&lt;/strong&gt;
Since propagate routine is performed at the beginning of the sequence, and the accumulate ate the end, the laplacian is computed combining, in the middle of sequence, the per-level gradient and divergence.&lt;/p&gt;

&lt;h2 id=&quot;adaptive-multigrid-preconditioner&quot;&gt;Adaptive multigrid preconditioner&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/voronowledge/assets/blog-images/spgrid/multigrid.png&quot; alt=&quot;multigrid&quot; class=&quot;image right&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image right caption&quot;&gt;&lt;strong&gt;Figure 7:&lt;/strong&gt; The pyramid used in the SPGrid is on the right. Yellow cells are introduced for the multigrid scheme. Source: original paper.&lt;/p&gt;

&lt;p&gt;To preconditionate the laplacian matrix and avoid instabilities in the simulation, a multigrid-based preconditioner  for adaptive grids is used.
For each level of the hierarchy, all cells are guaranteed to exist at the immediately coarser level. Such cells are created by copying the values of their counterparts on the next level of the octree (coarser level).&lt;/p&gt;

&lt;p&gt;At the bottom of the multigrid V-cycle, a non multigrid is used to solve the coarse level problem. The upstroke of the V-cycle is the adjoint of the downstroke: ghost values of $$\mathbf{u}$ are propagated such that finer cells receive information from coarse neighbors.&lt;/p&gt;

&lt;h2 id=&quot;advection-scheme&quot;&gt;Advection scheme&lt;/h2&gt;
&lt;p&gt;During the simulation, most of the time it is of interest to compute quantities at locations other than specific grid -aligned locations, while balancing convenience and accuracy. To do this, an unstructured interpolation is performed. Ideally, an interpolation scheme should:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/voronowledge/assets/blog-images/spgrid/interpolation.png&quot; alt=&quot;multigrid&quot; class=&quot;image left&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image left caption&quot;&gt;&lt;strong&gt;Figure 8:&lt;/strong&gt; Interpolation from cell centered values and from face centered values. Source: original paper.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;return the exact value if the target point coincides with a location where physical quantity is stored;&lt;/li&gt;
  &lt;li&gt;keep any advected quantity asymptotically unchanged.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;per-cell-interpolation&quot;&gt;Per-cell interpolation&lt;/h3&gt;
&lt;p&gt;Consider we want to intepolate a value at &lt;script type=&quot;math/tex&quot;&gt;(\xi_1,\xi_2)&lt;/script&gt;. First, a bilinear interpolation is performed at the center of the cell, obtaining &lt;script type=&quot;math/tex&quot;&gt;\phi_c^I&lt;/script&gt; from nodal values &lt;script type=&quot;math/tex&quot;&gt;\phi_{00},\cdots,\phi_{11}&lt;/script&gt;: $$\phi_c^I = \frac{(\phi_{00} + \phi_{01} + \phi_{10} + \phi_{11})}{4}$$&lt;/p&gt;

&lt;p&gt;Next, a correction &lt;script type=&quot;math/tex&quot;&gt;\delta\phi_c = \phi_c - \phi_c^I&lt;/script&gt; is computed and then, the final result for the interpolation scheme is obtained:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{eqnarray}
\phi(\xi_1,\xi_2) &amp;=&amp; \phi_{00}(1-\xi_1)(1-\xi_2) + \phi_{10}\xi_1(1-\xi_2) \\
    &amp;+&amp; \phi_{01}(1-\xi_1)\xi_2 + \phi_{11}\xi_1\xi_2 \\
    &amp;+&amp; 2\delta\phi_c\cdot\min{(\xi_1,1-xi_1,\xi_2,1-\xi_2)}
\end{eqnarray} %]]&gt;&lt;/script&gt;

&lt;h3 id=&quot;per-face-interpolation&quot;&gt;Per-face interpolation&lt;/h3&gt;
&lt;p&gt;In a three dimensional example, it is desired to obtain a value at the point &lt;script type=&quot;math/tex&quot;&gt;(\xi_1,\xi_2,\xi_3)&lt;/script&gt;. First, assume the value is in the normal to the &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;-axis. First, the interpolated values &lt;script type=&quot;math/tex&quot;&gt;u_L&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;u_R&lt;/script&gt; at the faces are obtained using the previous scheme. And then, a bilinear interpolation is performed: &lt;script type=&quot;math/tex&quot;&gt;u(&lt;/script&gt;(\xi_1,\xi_2,\xi_3)&lt;script type=&quot;math/tex&quot;&gt;) = u_L(1-\xi_1) + u_R\xi_1&lt;/script&gt;.&lt;/p&gt;</content><author><name>RNakanishi</name></author><category term="paper" /><summary type="html">Disclaimer: This paper was originally written by Rajsekhar Setaluri, Mridul Aanjaneya, Sean Bauer and Eftychios Sifakis. Originally published on ACM Transactions on Graphics, 2014.</summary></entry></feed>